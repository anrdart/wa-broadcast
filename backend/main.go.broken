package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"github.com/joho/godotenv"
	"go.mau.fi/whatsmeow"
	"go.mau.fi/whatsmeow/proto/waE2E"
	"go.mau.fi/whatsmeow/store/sqlstore"
	"go.mau.fi/whatsmeow/types"
	"go.mau.fi/whatsmeow/types/events"
	waLog "go.mau.fi/whatsmeow/util/log"
	"google.golang.org/protobuf/proto"
	_ "modernc.org/sqlite"
)

const (
	defaultPort = "3000"
)

var (
	// Load from environment with defaults
	// Note: These are initialized after godotenv.Load() in main()
	wsReadTimeout    = 60 * time.Second // Default values
	wsWriteTimeout   = 15 * time.Second
	connectRetryWait = 5 * time.Second
)

// contactPayload represents how a contact is sent to the frontend.
type contactPayload struct {
	ID          string `json:"id"`
	Name        string `json:"name,omitempty"`
	Number      string `json:"number"`
	IsMyContact bool   `json:"isMyContact"`
	IsFromCSV   bool   `json:"isFromCSV"`
}

// broadcastRequest is the payload received from the frontend when sending a broadcast.
type broadcastRequest struct {
	Type     string   `json:"type"`
	Message  string   `json:"message"`
	Contacts []string `json:"contacts"`
	Media    *struct {
		Data     string `json:"data"`
		MIMEType string `json:"mimetype"`
		Filename string `json:"filename"`
	} `json:"media,omitempty"`
}

// chatMessage represents a chat message
type chatMessage struct {
	Type      string `json:"type"`
	ContactID string `json:"contactId"`
	Message   string `json:"message"`
	Timestamp string `json:"timestamp,omitempty"`
}

// scheduleRequest represents a scheduled message request
type scheduleRequest struct {
	Type            string   `json:"type"`
	Message         string   `json:"message"`
	Contacts        []string `json:"contacts"`
	DateTime        string   `json:"dateTime"`
	IsRecurring     bool     `json:"isRecurring"`
	RecurringConfig *struct {
		Interval string `json:"interval"`
		EndDate  string `json:"endDate"`
	} `json:"recurringConfig,omitempty"`
}

// Server coordinates the WhatsApp client, WebSocket clients, and RealtimeKit.
type Server struct {
	waClient *whatsmeow.Client

	wsUpgrader websocket.Upgrader

	mu       sync.Mutex
	wsConns  map[*websocket.Conn]struct{}
	started  bool
	ctx      context.Context
	cancel   context.CancelFunc
	dataPath string

	// RealtimeKit integration
	realtimeKitEnabled bool
	realtimeKitURL     string

	// Chat and scheduling features
	activeChats    map[string][]chatMessage
	scheduledMsgs  []scheduleRequest
	scheduleTicker *time.Ticker
}

func newServer(rootCtx context.Context) (*Server, error) {
	ctx, cancel := context.WithCancel(rootCtx)

	// Get data directory from environment or use default
	dataDir := getEnv("WHATSAPP_DATA_DIR", filepath.Join(".", "data"))
	if err := os.MkdirAll(dataDir, 0o755); err != nil {
		cancel()
		return nil, fmt.Errorf("failed to create data directory: %w", err)
	}

	dbPath := filepath.Join(dataDir, "whatsmeow.db")
	dsn := fmt.Sprintf("file:%s?_pragma=foreign_keys(1)&_pragma=journal_mode(WAL)&_pragma=busy_timeout(10000)&_pragma=synchronous(NORMAL)&_pragma=cache_size(-64000)&_pragma=temp_store(MEMORY)", filepath.ToSlash(dbPath))

	container, err := sqlstore.New(ctx, "sqlite", dsn, waLog.Stdout("sqlstore", "WARN", false))
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to init sqlstore: %w", err)
	}

	deviceStore, err := container.GetFirstDevice(ctx)
	if err != nil {
		cancel()
		return nil, fmt.Errorf("failed to get device store: %w", err)
	}

	client := whatsmeow.NewClient(deviceStore, waLog.Stdout("whatsmeow", "INFO", false))
	// Check if auto-reconnect is enabled
	enableAutoReconnect := getEnv("ENABLE_AUTO_RECONNECT", "true") == "true"
	client.EnableAutoReconnect = enableAutoReconnect

	// Get RealtimeKit configuration from environment
	// Read AFTER .env is loaded in main()
	realtimeKitAPIKey := strings.TrimSpace(os.Getenv("REALTIMEKIT_API_KEY"))
	realtimeKitEnabled := getEnv("ENABLE_REALTIMEKIT", "false") == "true" && realtimeKitAPIKey != ""
	realtimeKitURL := getEnv("REALTIMEKIT_URL", "https://api.realtime.cloudflare.com")

	srv := &Server{
		waClient: client,
		wsUpgrader: websocket.Upgrader{
			HandshakeTimeout: wsWriteTimeout,
			CheckOrigin: func(r *http.Request) bool {
				return true
			},
		},
		wsConns:            make(map[*websocket.Conn]struct{}),
		ctx:                ctx,
		cancel:             cancel,
		dataPath:           dataDir,
		realtimeKitEnabled: realtimeKitEnabled,
		realtimeKitURL:     realtimeKitURL,
		activeChats:        make(map[string][]chatMessage),
		scheduledMsgs:      []scheduleRequest{},
	}

	client.AddEventHandler(srv.handleEvent)

	// Initialize RealtimeKit if enabled
	if srv.realtimeKitEnabled {
		log.Printf("‚úÖ RealtimeKit enabled - API URL: %s", srv.realtimeKitURL)
		log.Printf("üì° RealtimeKit Channel: %s", getEnv("REALTIMEKIT_CHANNEL", "broadcasto-sync"))
		// Validate API key format
		if !strings.HasPrefix(realtimeKitAPIKey, "rtk_") {
			log.Printf("‚ö†Ô∏è  Warning: RealtimeKit API key should start with 'rtk_'")
		}
		// TODO: Initialize RealtimeKit client here
		// This would involve creating a RealtimeKit client instance
		// and setting up message handlers for cross-client communication
	} else {
		log.Printf("‚ÑπÔ∏è  RealtimeKit not configured - running in WebSocket-only mode")
		if realtimeKitAPIKey == "" {
			log.Printf("üí° Tip: Set REALTIMEKIT_API_KEY in .env for multi-client sync")
		}
	}

	// Initialize scheduling system with configurable interval
	scheduleInterval := getEnvInt("SCHEDULE_CHECK_INTERVAL", 30)
	if scheduleInterval <= 0 {
		scheduleInterval = 30 // Fallback to default if invalid
	}
	srv.scheduleTicker = time.NewTicker(time.Duration(scheduleInterval) * time.Second)
	if getEnv("ENABLE_SCHEDULING", "true") == "true" {
		go srv.processScheduledMessages()
		log.Printf("üìÖ Message scheduling enabled (check interval: %ds)", scheduleInterval)
	}

	return srv, nil
}

// Start establishes the WhatsApp connection (with retries).
func (s *Server) Start() {
	s.mu.Lock()
	if s.started {
		s.mu.Unlock()
		return
	}
	s.started = true
	s.mu.Unlock()

	go func() {
		for {
			select {
			case <-s.ctx.Done():
				return
			default:
			}

			err := s.waClient.Connect()
			if err == nil {
				return
			}

			if errors.Is(err, whatsmeow.ErrAlreadyConnected) {
				return
			}

			log.Printf("whatsmeow connect failed: %v", err)
			time.Sleep(connectRetryWait)
		}
	}()
}

func (s *Server) Stop() {
	s.cancel()
	if s.scheduleTicker != nil {
		s.scheduleTicker.Stop()
	}
	s.waClient.Disconnect()
	s.mu.Lock()
	for conn := range s.wsConns {
		_ = conn.Close()
	}
	s.wsConns = make(map[*websocket.Conn]struct{})
	s.mu.Unlock()
}

func (s *Server) handleHTTP(w http.ResponseWriter, r *http.Request) {
	if websocket.IsWebSocketUpgrade(r) {
		s.handleWebSocket(w, r)
		return
	}
	w.WriteHeader(http.StatusOK)
	_, _ = w.Write([]byte("WhatsApp broadcast backend is running.\n"))
}

func (s *Server) handleWebSocket(w http.ResponseWriter, r *http.Request) {
	conn, err := s.wsUpgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("websocket upgrade failed: %v", err)
		return
	}

	conn.SetReadLimit(1 << 20) // 1MB
	conn.SetReadDeadline(time.Now().Add(wsReadTimeout))
	conn.SetPongHandler(func(string) error {
		conn.SetReadDeadline(time.Now().Add(wsReadTimeout))
		return nil
	})

	s.mu.Lock()
	s.wsConns[conn] = struct{}{}
	s.mu.Unlock()

	s.Start()

	// If already connected, notify client immediately.
	if s.waClient.IsLoggedIn() {
		s.sendTo(conn, map[string]any{
			"type": "authenticated",
		})
		s.sendReady(conn)
	}

	go s.writePing(conn)
	s.readLoop(conn)
}

func (s *Server) readLoop(conn *websocket.Conn) {
	defer func() {
		s.mu.Lock()
		delete(s.wsConns, conn)
		s.mu.Unlock()
		_ = conn.Close()
	}()

	for {
		_, payload, err := conn.ReadMessage()
		if err != nil {
			return
		}

		// Generic message structure to determine type
		var genericMsg struct {
			Type string `json:"type"`
		}
		if err := json.Unmarshal(payload, &genericMsg); err != nil {
			s.sendTo(conn, map[string]any{
				"type":    "error",
				"message": fmt.Sprintf("invalid payload: %v", err),
			})
			continue
		}

		switch strings.ToLower(genericMsg.Type) {
		case "get_contacts":
			s.sendContacts(conn)
		case "send_broadcast":
			var message broadcastRequest
			if err := json.Unmarshal(payload, &message); err != nil {
				s.sendTo(conn, map[string]any{
					"type":    "error",
					"message": fmt.Sprintf("invalid broadcast payload: %v", err),
				})
				continue
			}
			s.handleBroadcast(conn, message)
		case "send_chat":
			s.handleChatMessage(conn, payload)
		case "schedule_message":
			s.handleScheduleMessage(conn, payload)
		case "get_scheduled":
			s.sendScheduledMessages(conn)
		case "logout":
			s.handleLogout(conn)
		default:
			s.sendTo(conn, map[string]any{
				"type":    "error",
				"message": fmt.Sprintf("unknown command: %s", genericMsg.Type),
			})
		}
	}
}

func (s *Server) writePing(conn *websocket.Conn) {
	ticker := time.NewTicker(20 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-s.ctx.Done():
			return
		case <-ticker.C:
			s.mu.Lock()
			_, ok := s.wsConns[conn]
			s.mu.Unlock()
			if !ok {
				return
			}
			conn.SetWriteDeadline(time.Now().Add(wsWriteTimeout))
			if err := conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		}
	}
}

func (s *Server) sendContacts(conn *websocket.Conn) {
	if !s.waClient.IsLoggedIn() {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": "WhatsApp belum terhubung.",
		})
		return
	}

	ctx, cancel := context.WithTimeout(s.ctx, 15*time.Second)
	defer cancel()

	contacts, err := s.waClient.Store.Contacts.GetAllContacts(ctx)
	if err != nil {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": fmt.Sprintf("gagal mengambil kontak: %v", err),
		})
		return
	}

	result := make([]contactPayload, 0, len(contacts))
	for jid, info := range contacts {
		if jid.Server != types.DefaultUserServer {
			continue
		}
		result = append(result, contactPayload{
			ID:          jid.String(),
			Name:        pickName(info),
			Number:      formatNumber(jid.User),
			IsMyContact: true,
		})
	}

	s.sendTo(conn, map[string]any{
		"type":     "contacts",
		"contacts": result,
	})
}

func (s *Server) handleBroadcast(conn *websocket.Conn, req broadcastRequest) {
	if !s.waClient.IsLoggedIn() {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": "WhatsApp belum terhubung.",
		})
		return
	}
	if req.Message == "" || len(req.Contacts) == 0 {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": "Pesan dan daftar kontak harus diisi.",
		})
		return
	}
	if req.Media != nil {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": "Pengiriman media belum didukung pada backend WhatsMeow ini.",
		})
		return
	}

	total := len(req.Contacts)
	successful := 0
	failed := 0

	// Send broadcast start notification via RealtimeKit if enabled
	if s.realtimeKitEnabled {
		s.broadcastRealtimeMessage(map[string]any{
			"type": "broadcast_started",
			"data": map[string]any{
				"message": req.Message,
				"total":   total,
			},
		})
	}

	for index, contactID := range req.Contacts {
		jid, err := parseContactJID(contactID)
		display := contactPayload{
			ID:          contactID,
			Number:      contactID,
			IsMyContact: true,
		}

		if err != nil {
			failed++
			progressMsg := map[string]any{
				"type":    "broadcast_progress",
				"current": index + 1,
				"total":   total,
				"contact": display,
				"error":   fmt.Sprintf("format nomor invalid: %v", err),
			}
			s.broadcast(progressMsg)

			// Broadcast progress via RealtimeKit
			if s.realtimeKitEnabled {
				s.broadcastRealtimeMessage(map[string]any{
					"type": "broadcast_update",
					"data": progressMsg,
				})
			}
			continue
		}

		message := &waE2E.Message{
			Conversation: proto.String(req.Message),
		}

		if _, err := s.waClient.SendMessage(s.ctx, jid, message); err != nil {
			failed++
			progressMsg := map[string]any{
				"type":    "broadcast_progress",
				"current": index + 1,
				"total":   total,
				"contact": display,
				"error":   err.Error(),
			}
			s.broadcast(progressMsg)

			// Broadcast progress via RealtimeKit
			if s.realtimeKitEnabled {
				s.broadcastRealtimeMessage(map[string]any{
					"type": "broadcast_update",
					"data": progressMsg,
				})
			}
			continue
		}

		successful++
		progressMsg := map[string]any{
			"type":    "broadcast_progress",
			"current": index + 1,
			"total":   total,
			"contact": display,
			"success": true,
		}
		s.broadcast(progressMsg)

		// Broadcast progress via RealtimeKit
		if s.realtimeKitEnabled {
			s.broadcastRealtimeMessage(map[string]any{
				"type": "broadcast_update",
				"data": progressMsg,
			})
		}
	}

	completeMsg := map[string]any{
		"type":       "broadcast_complete",
		"successful": successful,
		"failed":     failed,
		"total":      total,
	}
	s.broadcast(completeMsg)

	// Broadcast completion via RealtimeKit
	if s.realtimeKitEnabled {
		s.broadcastRealtimeMessage(map[string]any{
			"type": "broadcast_complete",
			"data": completeMsg,
		})
	}
}

func (s *Server) handleLogout(conn *websocket.Conn) {
	if !s.waClient.IsLoggedIn() {
		return
	}
	if err := s.waClient.Logout(s.ctx); err != nil {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": fmt.Sprintf("gagal logout: %v", err),
		})
	}
}

func (s *Server) handleEvent(evt any) {
	switch event := evt.(type) { //nolint: exhaustive
	case *events.QR:
		if len(event.Codes) == 0 {
			return
		}
		// Broadcast in goroutine to avoid blocking event handler
		go s.broadcast(map[string]any{
			"type": "qr_code",
			"qr":   event.Codes[0],
		})
</text>

<old_text line=551>
	case *events.PairSuccess:
		go s.broadcast(map[string]any{
			"type": "authenticated",
		})
	case *events.Connected:
		go s.broadcast(map[string]any{
			"type": "ready",
		})
	case *events.StreamReplaced:
		go s.broadcast(map[string]any{
			"type":    "disconnected",
			"message": "Sesi digantikan oleh koneksi lain.",
		})
	case *events.LoggedOut:
		go s.broadcast(map[string]any{
			"type":    "disconnected",
			"message": "Terlogout dari WhatsApp.",
		})
	case *events.Disconnected:
		go s.broadcast(map[string]any{
			"type":    "disconnected",
			"message": "Koneksi WhatsApp terputus.",
		})
	case *events.TemporaryBan:
		go s.broadcast(map[string]any{
			"type":    "error",
			"message": fmt.Sprintf("Sementara diblokir oleh WhatsApp (%s)", event.String()),
		})
	case *events.StreamError:
		go s.broadcast(map[string]any{
			"type":    "error",
			"message": fmt.Sprintf("Stream error: %s", event.Code),
		})
	case *events.ConnectFailure:
		go s.broadcast(map[string]any{
			"type":    "error",
			"message": fmt.Sprintf("Gagal koneksi: %s", event.Message),
		})
	}
}

func (s *Server) sendReady(conn *websocket.Conn) {
	s.sendTo(conn, map[string]any{
		"type": "ready",
	})
}

func (s *Server) broadcast(message map[string]any) {
	s.mu.Lock()
	// Create a slice of connections to avoid holding lock during writes
	conns := make([]*websocket.Conn, 0, len(s.wsConns))
	for conn := range s.wsConns {
		conns = append(conns, conn)
	}
	s.mu.Unlock()

	// Write to each connection without holding the lock
	for _, conn := range conns {
		conn.SetWriteDeadline(time.Now().Add(wsWriteTimeout))
		if err := conn.WriteJSON(message); err != nil {
			log.Printf("failed to write to websocket: %v", err)
			// Clean up the failed connection
			s.mu.Lock()
			if _, exists := s.wsConns[conn]; exists {
				conn.Close()
				delete(s.wsConns, conn)
			}
			s.mu.Unlock()
		}
	}
}
</text>

<old_text line=614>
func (s *Server) sendTo(conn *websocket.Conn, message map[string]any) {
	conn.SetWriteDeadline(time.Now().Add(wsWriteTimeout))
	if err := conn.WriteJSON(message); err != nil {
		log.Printf("failed to send message: %v", err)
		conn.Close()
		s.mu.Lock()
		delete(s.wsConns, conn)
		s.mu.Unlock()
	}
}
</text>
<new_text>
func (s *Server) sendTo(conn *websocket.Conn, message map[string]any) {
	// Set a shorter deadline for individual sends
	deadline := time.Now().Add(wsWriteTimeout)
	conn.SetWriteDeadline(deadline)

	if err := conn.WriteJSON(message); err != nil {
		log.Printf("failed to send message to client: %v", err)
		// Clean up the failed connection
		s.mu.Lock()
		if _, exists := s.wsConns[conn]; exists {
			conn.Close()
			delete(s.wsConns, conn)
		}
		s.mu.Unlock()
	}
}
</text>


func (s *Server) sendTo(conn *websocket.Conn, message map[string]any) {
	conn.SetWriteDeadline(time.Now().Add(wsWriteTimeout))
	if err := conn.WriteJSON(message); err != nil {
		log.Printf("failed to send message: %v", err)
		conn.Close()
		s.mu.Lock()
		delete(s.wsConns, conn)
		s.mu.Unlock()
	}
}

// broadcastRealtimeMessage broadcasts a message via RealtimeKit to all connected clients
func (s *Server) broadcastRealtimeMessage(message map[string]any) {
	if !s.realtimeKitEnabled {
		return
	}

	// TODO: Implement actual RealtimeKit broadcasting
	// This would send the message to the RealtimeKit room/channel
	// For now, this is a placeholder that logs the message
	log.Printf("RealtimeKit broadcast: %+v", message)

	// In a real implementation, this would make an HTTP POST request to RealtimeKit API
	// Example:
	// endpoint := fmt.Sprintf("%s/v1/rooms/%s/broadcast", s.realtimeKitURL, realtimeKitRoomID)
	// payload := map[string]any{"message": message}
	// // Send HTTP request with authorization header: "Authorization: Bearer " + realtimeKitAPIKey
}

// handleChatMessage processes chat messages
func (s *Server) handleChatMessage(conn *websocket.Conn, rawMessage json.RawMessage) {
	var msg chatMessage
	if err := json.Unmarshal(rawMessage, &msg); err != nil {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": fmt.Sprintf("invalid chat message: %v", err),
		})
		return
	}

	if msg.ContactID == "" || msg.Message == "" {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": "Contact ID and message are required",
		})
		return
	}

	// Store chat message
	if s.activeChats[msg.ContactID] == nil {
		s.activeChats[msg.ContactID] = []chatMessage{}
	}
	msg.Timestamp = time.Now().Format(time.RFC3339)
	s.activeChats[msg.ContactID] = append(s.activeChats[msg.ContactID], msg)

	// Send message via WhatsApp (if connected)
	if s.waClient.IsLoggedIn() {
		jid, err := parseContactJID(msg.ContactID)
		if err == nil {
			message := &waE2E.Message{
				Conversation: proto.String(msg.Message),
			}
			if _, err := s.waClient.SendMessage(s.ctx, jid, message); err != nil {
				log.Printf("Failed to send chat message: %v", err)
			}
		}
	}

	// Store in active chats and broadcast to all connected clients
	if s.activeChats[msg.ContactID] == nil {
		s.activeChats[msg.ContactID] = []chatMessage{}
	}
	s.activeChats[msg.ContactID] = append(s.activeChats[msg.ContactID], msg)

	// Broadcast to all connected clients except sender
	chatBroadcast := map[string]any{
		"type":      "chat_message",
		"contactId": msg.ContactID,
		"message":   msg,
	}
	s.broadcast(chatBroadcast)

	// Also broadcast via RealtimeKit if enabled
	if s.realtimeKitEnabled {
		s.broadcastRealtimeMessage(chatBroadcast)
	}
}

// handleScheduleMessage schedules a message for future sending
func (s *Server) handleScheduleMessage(conn *websocket.Conn, rawMessage json.RawMessage) {
	var req scheduleRequest
	if err := json.Unmarshal(rawMessage, &req); err != nil {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": fmt.Sprintf("invalid schedule request: %v", err),
		})
		return
	}

	if req.Message == "" || req.DateTime == "" || len(req.Contacts) == 0 {
		s.sendTo(conn, map[string]any{
			"type":    "error",
			"message": "Message, date/time, and contacts are required",
		})
		return
	}

	// Add to scheduled messages
	s.scheduledMsgs = append(s.scheduledMsgs, req)

	s.sendTo(conn, map[string]any{
		"type":    "schedule_success",
		"message": "Message scheduled successfully",
	})
}

// sendScheduledMessages sends the list of scheduled messages to client
func (s *Server) sendScheduledMessages(conn *websocket.Conn) {
	s.sendTo(conn, map[string]any{
		"type":     "scheduled_messages",
		"messages": s.scheduledMsgs,
	})

	// Also broadcast via RealtimeKit if enabled
	if s.realtimeKitEnabled {
		s.broadcastRealtimeMessage(map[string]any{
			"type":     "scheduled_update",
			"messages": s.scheduledMsgs,
		})
	}
}

// processScheduledMessages checks and sends scheduled messages
func (s *Server) processScheduledMessages() {
	for {
		select {
		case <-s.ctx.Done():
			return
		case <-s.scheduleTicker.C:
			now := time.Now()
			var remaining []scheduleRequest

			for _, msg := range s.scheduledMsgs {
				scheduledTime, err := time.Parse(time.RFC3339, msg.DateTime)
				if err != nil {
					log.Printf("Invalid scheduled time: %v", err)
					continue
				}

				if now.After(scheduledTime) || now.Equal(scheduledTime) {
					// Send the message
					s.sendScheduledMessage(msg)
				} else {
					// Keep for future processing
					remaining = append(remaining, msg)
				}
			}

			s.scheduledMsgs = remaining
		}
	}
}

// sendScheduledMessage sends a scheduled message
func (s *Server) sendScheduledMessage(msg scheduleRequest) {
	if !s.waClient.IsLoggedIn() {
		log.Printf("Cannot send scheduled message - WhatsApp not connected")
		return
	}

	successful := 0
	failed := 0

	for _, contactID := range msg.Contacts {
		jid, err := parseContactJID(contactID)
		if err != nil {
			failed++
			continue
		}

		message := &waE2E.Message{
			Conversation: proto.String(msg.Message),
		}

		if _, err := s.waClient.SendMessage(s.ctx, jid, message); err != nil {
			failed++
			log.Printf("Failed to send scheduled message to %s: %v", contactID, err)
		} else {
			successful++
		}
	}

	log.Printf("Scheduled message sent: %d successful, %d failed", successful, failed)

	// Notify all clients about the sent scheduled message
	scheduledNotification := map[string]any{
		"type":       "scheduled_sent",
		"message":    msg.Message,
		"successful": successful,
		"failed":     failed,
	}
	s.broadcast(scheduledNotification)

	// Also broadcast via RealtimeKit if enabled
	if s.realtimeKitEnabled {
		s.broadcastRealtimeMessage(scheduledNotification)
	}
}

func pickName(info types.ContactInfo) string {
	switch {
	case strings.TrimSpace(info.FullName) != "":
		return info.FullName
	case strings.TrimSpace(info.FirstName) != "":
		return info.FirstName
	case strings.TrimSpace(info.PushName) != "":
		return info.PushName
	case strings.TrimSpace(info.BusinessName) != "":
		return info.BusinessName
	default:
		return ""
	}
}

func formatNumber(user string) string {
	if user == "" {
		return user
	}
	if strings.HasPrefix(user, "62") {
		return "0" + user[2:]
	}
	return user
}

func parseContactJID(id string) (types.JID, error) {
	if id == "" {
		return types.EmptyJID, errors.New("empty contact id")
	}

	// Web frontends often send IDs like "62812...@s.whatsapp.net" or "...@c.us".
	if strings.Contains(id, "@") {
		jid, err := types.ParseJID(id)
		if err == nil && jid.Server != "" {
			if jid.Server == "c.us" {
				jid.Server = types.DefaultUserServer
			}
			return jid, nil
		}
	}

	normalized := strings.TrimSpace(id)
	normalized = strings.TrimPrefix(normalized, "+")
	normalized = strings.ReplaceAll(normalized, " ", "")

	if normalized == "" {
		return types.EmptyJID, fmt.Errorf("nomor kosong")
	}

	return types.NewJID(normalized, types.DefaultUserServer), nil
}

func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
	if value := os.Getenv(key); value != "" {
		if intVal, err := strconv.Atoi(value); err == nil {
			return intVal
		}
	}
	return defaultValue
}

func getEnvDuration(key string, defaultValue time.Duration) time.Duration {
	if value := os.Getenv(key); value != "" {
		if intVal, err := strconv.Atoi(value); err == nil {
			return time.Duration(intVal) * time.Second
		}
	}
	return defaultValue
}

func main() {
	// Load .env file FIRST before reading any environment variables
	if err := godotenv.Load(); err != nil {
		log.Printf("No .env file found, using environment variables or defaults")
	}

	// Override timeout variables from .env if specified
	if envReadTimeout := getEnvDuration("WS_READ_TIMEOUT", 0); envReadTimeout > 0 {
		wsReadTimeout = envReadTimeout * time.Second
	}
	if envWriteTimeout := getEnvDuration("WS_WRITE_TIMEOUT", 0); envWriteTimeout > 0 {
		wsWriteTimeout = envWriteTimeout * time.Second
	}
	if envRetryWait := getEnvDuration("CONNECT_RETRY_WAIT", 0); envRetryWait > 0 {
		connectRetryWait = envRetryWait * time.Second
	}
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	server, err := newServer(ctx)
	if err != nil {
		log.Fatalf("failed to start backend: %v", err)
	}

	defer server.Stop()

	mux := http.NewServeMux()
	mux.HandleFunc("/", server.handleHTTP)
	mux.HandleFunc("/healthz", func(w http.ResponseWriter, _ *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("ok"))
	})

	// Get port from environment
	port := getEnv("PORT", defaultPort)
	address := ":" + port
	log.Printf("Starting WhatsMeow backend on %s ...", address)
	if err := http.ListenAndServe(address, mux); err != nil && !errors.Is(err, http.ErrServerClosed) {
		log.Fatalf("http server error: %v", err)
	}
}
